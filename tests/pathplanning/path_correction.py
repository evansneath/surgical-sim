#!/usr/bin/env python

import numpy as np
import matplotlib.pyplot as plt

import surgicalsim.lib.datastore as datastore
import surgicalsim.lib.constants as constants
import surgicalsim.lib.pathutils as pathutils


def main():
    path_file = '/Users/evansneath/Workspace/surgicalsim/results/sample5.dat'
    path = datastore.retrieve(path_file)

    # A list of the the segments of the optimized path
    segments = pathutils._detect_segments(path)

    # The new path generated by original path and corrective algorithm
    corrected_path = None

    max_vel = 1.0 # [m/s]

    total_path_offset = 0.0
    target_error = 0.0

    for i, _ in enumerate(path):
        # Detect current segment
        seg_idx = 0
        for j in range(len(segments)):
            if i <= j:
                seg_idx = j
                break

        # Get the final tooltip position in the current segment
        target_pos = path[segments[seg_idx]-1][constants.G_POS_IDX:constants.G_POS_IDX+constants.G_NUM_POS_DIMS]

        # TODO: Get current gate position
        gate_pos = generate_gate_pos(path, seg_idx)

        # Get current time and position
        curr_time = path[i][constants.G_TIME_IDX]

        if i == 0:
            prev_time = curr_time
        else:
            prev_time = path[i-1][constants.G_TIME_IDX]

        dt = curr_time - prev_time

        curr_pos = path[i][constants.G_POS_IDX:constants.G_POS_IDX+constants.G_NUM_POS_DIMS]

        if i == 0:
            prev_pos = curr_pos
        else:
            prev_pos = path[i-1][constants.G_POS_IDX:constants.G_POS_IDX+constants.G_NUM_POS_DIMS]

        dpos = curr_pos - prev_pos

        # Calculate current offset from the target gate
        target_error += gate_pos - (target_pos + total_path_offset)

        # Calculate next velocity
        if i == 0:
            vel = 0.0
        else:
            vel = dpos / dt

        # Calculate the modifier for the velocity
        vel_modified = np.clip(target_error+vel, -max_vel, max_vel)

        dpos_modified = vel_modified * dt

        # Calculate the next position corrected to gate velocity
        corrected_pos = prev_pos + dpos_modified

        # Store the next movement for later
        if corrected_path is None:
            corrected_path = corrected_pos
        else:
            corrected_path = np.vstack((corrected_path, corrected_pos))

        total_path_offset += dpos_modified - dpos
        target_error -= dpos_modified - dpos

    # Plot the inputted path
    fig = plt.figure(facecolor='white')
    axis = fig.gca(projection='3d')

    full_path = path.copy()
    full_path[:,constants.G_POS_IDX:constants.G_POS_IDX+constants.G_NUM_POS_DIMS] = corrected_path

    pathutils.display_path(axis, full_path, title='Path')

    plt.show()

    return


def generate_gate_pos(path, segment_num):
    return 2.0


if __name__ == '__main__':
    main()
