#!/usr/bin/env python

import numpy as np
import matplotlib.pyplot as plt

import surgicalsim.lib.datastore as datastore
import surgicalsim.lib.constants as constants
import surgicalsim.lib.pathutils as pathutils


def main():
    path_file = '../../results/sample5.dat'
    path = datastore.retrieve(path_file)

    # A list of the the segments of the optimized path
    segments = pathutils._detect_segments(path)

    # The new path generated by original path and corrective algorithm
    new_path = None

    pos_start_col = constants.G_POS_IDX
    pos_end_col = pos_start_col + constants.G_NUM_POS_DIMS

    max_vel = 2.0 # [m/s]

    total_path_offset = 0.0
    target_error = 0.0

    for i, _ in enumerate(path):
        if i == len(path) - 1:
            continue

        # Detect current segment
        seg_idx = 0

        for j in range(len(segments)):
            if i <= segments[j]:
                seg_idx = j
                break

        # Get current time and position
        curr_time = path[i,constants.G_TIME_IDX]
        next_time = path[i+1,constants.G_TIME_IDX]

        curr_pos = path[i,pos_start_col:pos_end_col] + total_path_offset
        next_pos = path[i+1,pos_start_col:pos_end_col] + total_path_offset

        # Calculate next velocity
        dt = next_time - curr_time
        dpos = next_pos - curr_pos
        vel = dpos / dt

        # Get the final tooltip position in the current segment
        target_pos = path[segments[seg_idx],pos_start_col:pos_end_col]

        # Get current gate position
        gate_pos = generate_gate_pos(curr_time, path, seg_idx)

        # Calculate current offset from the target gate
        target_error = gate_pos - (target_pos + total_path_offset)

        # Calculate the modifier for the velocity
        vel_mod = np.clip(target_error/dt, -max_vel+vel, max_vel-vel)

        new_vel = vel + vel_mod

        new_dpos = new_vel * dt

        # Calculate the next position corrected to gate velocity
        new_pos = curr_pos + new_dpos

        # Store the next movement for later
        if new_path is None:
            new_path = new_pos
        else:
            new_path = np.vstack((new_path, new_pos))

        total_path_offset += new_dpos - dpos

    # Plot the inputted path
    fig = plt.figure(facecolor='white')
    axis = fig.gca(projection='3d')

    full_path = path[:-1].copy()
    full_path[:,pos_start_col:pos_end_col] = new_path

    pathutils.display_path(axis, full_path, title='Path')

    plt.show()

    return


def generate_gate_pos(t, path, segment_num):
    gate_start_col = constants.G_GATE_IDX+(constants.G_NUM_GATE_DIMS*segment_num)
    gate_end_col = gate_start_col + constants.G_NUM_POS_DIMS

    gate_pos = path[0,gate_start_col:gate_end_col].copy()

    f = 4.0
    gate_pos += np.array([0.0, 0.02*np.sin(2.0*np.pi*f*t), 0.0])

    return gate_pos


if __name__ == '__main__':
    main()
